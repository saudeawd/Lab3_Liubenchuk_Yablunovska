# Lab3_Liubenchuk_Yablunovska: Відгук на бібліотеку стрічок

**Оцінка:** 8/10

## 1. Якість пакету (2/2.5)

### Позитивні моменти:
- Чіткий поділ на `.h` та `.cpp` файли
- Наявність `README.md` з інструкціями
- Присутній `CMakeLists.txt` для збірки
- Include guards правильно реалізовані
- Доданий `.gitignore`

### Недоліки:
- В `CMakeLists.txt` відсутня перевірка компілятора для прапорців
- Немає окремого `examples/` та `library/` поділу
- Скрипт `compile.sh` видаляє весь `build/` без попередження

**Рекомендації:**
```cmake
# Краще так:
if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)
    add_compile_options(-Wall -Wextra -pedantic -Werror=vla)
elseif(MSVC)
    add_compile_options(/W4)
endif()
```

## 2. Якість інтерфейсу (2.5/2.5)

### Позитивні моменти:
- Повна відповідність вимогам завдання
- Всі необхідні методи присутні
- Додаткові оператори (`*`, `*=`, `+`, `+=`)
- Move-семантика реалізована
- C API binding наявний

### Зауваження:
- Інтерфейс інтуїтивний та зручний
- Оператори поводяться передбачувано
- Хороша консистентність імен методів

## 3. Якість реалізації (2/3)

### Позитивні моменти:
- Пам'ять керується коректно (перевірено valgrind)
- Використання `memmove` для перекриваючихся областей
- Оптимізація: вирівнювання на 16 байт
- Розумна стратегія росту capacity (×2 до 1024, +1024 після)

### Виявлені проблеми:

#### Критична проблема 1: Некоректна робота `find` з пустою C-стрічкою
```cpp
size_t my_str_t::find(const char* cstr, size_t idx) const {
    // ...
    for (; idx < size_m; idx++) {
        bool flagEqual = false;
        bool flagNotEqual = false;
        
        for (size_t j = 0; j < size_m - idx + 1; j++) {
            if (cstr[j] == '\0') {  // Пуста стрічка завжди знаходиться!
                flagEqual = true;
                break;
            }
            // ...
        }
    }
}
```

**Проблема:** Пуста C-стрічка (`""`) вважається знайденою на будь-якій позиції.  
**Очікувана поведінка:** Повертати `not_found`.

#### Проблема 2: Неефективність у `find` для `std::string`
```cpp
size_t my_str_t::find(const std::string& str, size_t idx) const {
    for (; idx < size_m - str.size() + 1; idx++) {
        bool flagEqual = true;
        for (size_t j = 0; j < str.size(); j++)  // Вкладений цикл
            if (data_m[idx + j] != str[j]) {
                flagEqual = false;
                break;
            }
        if (flagEqual) return idx;
    }
}
```

**Рекомендація:** Використати алгоритм Boyer-Moore або KMP для O(n+m).  
**Або просто:** `strstr()` з libc для C-стрічок.

#### Проблема 3: Відключене вирівнювання
```cpp
void my_str_t::reserve(const size_t new_capacity) {
    // new_capacity = evaluate_capacity(new_capacity);
    // Disabled alignment because tests fail
```

**Коментар у коді:** "Disabled alignment because tests fail"  
**Проблема:** Вирівнювання відключене через тести, хоча воно покращує продуктивність.

#### Проблема 4: Порушення const-коректності
```cpp
void my_str_t::write(const char* buffer, const size_t begin, 
                     const size_t size) const {
    memcpy(data_m + begin, buffer, size);  // const метод змінює data_m!
}
```

**Проблема:** Метод `write()` оголошений `const`, але змінює дані!  
**Виправлення:** Прибрати `const` або зробити справжнім const-методом.

### Позитивні моменти реалізації:
- Використання `memmove` замість `memcpy` для перекриваючихся областей
- Swap-ідіома в операторі присвоєння
- Move-конструктор реалізований ефективно

## 4. Якість коду (1.5/2)

### Позитивні моменти:
- Код читабельний та добре структурований
- Використання inline для малих функцій
- Коментарі PVS-Studio присутні
- Хороша організація файлів

### Недоліки:
- Непослідовність: `flagEqual` замість `flag_equal`
- Магічні числа: `1024` в коді без пояснення
- Коментарі "Disabled because tests fail" - smell code

**Рекомендації:**
```cpp
// Замість:
if (old_capacity > 1024) {
    new_capacity = old_capacity + 1024;
}

// Краще:
constexpr size_t LARGE_CAPACITY_THRESHOLD = 1024;
constexpr size_t LARGE_INCREMENT = 1024;

if (old_capacity > LARGE_CAPACITY_THRESHOLD) {
    new_capacity = old_capacity + LARGE_INCREMENT;
}
```

## 5. Додаткові можливості (+бонус)

- Оператори `*` та `*=` для повторення
- Move-семантика
- C API binding
- Оператор `<=>` (C++20)

## Висновок

### Загальне враження:
Бібліотека **добре реалізована** і **повністю функціональна**. Основні операції працюють коректно, пам'ять керується правильно. Інтерфейс зручний та інтуїтивний.

### Що вдалося особливо добре:
- Move-семантика та оператори присвоєння
- Стратегія росту capacity
- C API binding
- Загальна архітектура

### Що потребує покращення:
- Алгоритми пошуку (продуктивність)
- Граничні випадки (пусті стрічки)
- Const-коректність
- Документація коду

### Чи виникли проблеми при використанні:
**Ні критичних проблем.** Всі необхідні для завдання функції працюють коректно. Бібліотеку було легко інтегрувати та використовувати.

### Фінальна оцінка: **8/10**
